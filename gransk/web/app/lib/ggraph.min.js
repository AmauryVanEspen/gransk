var marker = (function() {
  var poly;
  var points = [];
  var max_radius = 0;
  var selected = {};
  var callbacks = [];
  var state = {started: false}

  // https://github.com/Jam3/chaikin-smooth
  var smooth = function(input, output) {
    if (!Array.isArray(output))
        output = []

    if (input.length>0 && input[0]) {
        output.push([input[0][0], input[0][1]])
    }
    for (var i=0; i<input.length-1; i++) {
        var p0 = input[i]
        var p1 = input[i+1]
        var p0x = p0[0],
            p0y = p0[1],
            p1x = p1[0],
            p1y = p1[1]

        var Q = [ 0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y ]
        var R = [ 0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y ]
        output.push(Q)
        output.push(R)
    }
    if (input.length > 1) {
      output.push([input[input.length-1][0], input[input.length-1][1]])

    }

    return output
  }

  var is_in = function(point) {
      var vs = marker.points;
      var x = point[0], y = point[1];
      var inside = false;
      for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
          var xi = vs[i][0], yi = vs[i][1];
          var xj = vs[j][0], yj = vs[j][1];
          var intersect = ((yi > y) != (yj > y))
              && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
      }
      return inside;
  };

  var to_str = function(points, skip, do_smooth) {
    var arr = [];

    var x = [];
    points.map(function(a,i ) {
      if (i % skip == 0) x.push(a)
    });

    x.push(points[points.length - 1]);

    if (do_smooth) {
      x = smooth(x);
    }
    x.map(function(point) {
      arr.push(point[0] + ',' + point[1])
    })

    return arr.join(' ')
  }

  var register = function(callback) {
    callbacks.push(callback);
  };

  var call = function(clear) {
    callbacks.map(function(callback) {
      callback(clear);
    })
  }

  var get_mouse_pos = function() {
    return {
      x: d3.event.clientX + offset_x,
      y: d3.event.clientY + offset_y,
    }
  }

  var init = function(container, background, _transform, _offset_x, _offset_y) {
    poly = container.append('polygon').attr('class', 'polygon')
    transform = _transform;
    offset_x = _offset_x;
    offset_y = _offset_y;
    state.started = false;
    marker.points = [];

    background.on('contextmenu', function() {
      call(!d3.event.shiftKey);
      state.started = true;
    });

    document.addEventListener('mouseup', function() {
      state.started = false;
      marker.points = [];
      poly.attr('points', to_str(marker.points, 4, true));
    });

    background.on('mousemove', function() {
      if (!state.started) return;
      var pos = marker.get_mouse_pos()
      var x = (pos.x - transform.current.x) / transform.current.k;
      var y = (pos.y - transform.current.y) / transform.current.k;
      marker.points.push([x, y])
      poly.attr('points', to_str(marker.points, 4, true));
      call();
    });
  }

  return {
    init: init,
    marked: register,
    contains: is_in,
    state: state,
    get_mouse_pos: get_mouse_pos,
    points: points,
    to_str: to_str,
    set: function(points) {
      marker.points = points;
      call(true);
    }
  }
})();

var ladjust = (function() {
  var create_rect = function(node) {
      return {
        left: (node.x - node.width / 2) - 1,
        right: (node.x + node.width / 2) + 1,
        top: (node.y - node.height / 2) - 1,
        bottom: (node.y + node.height / 2) + 1
      }
  }

  var collision = function(a, b) {
    var r1 = create_rect(a);
    var r2 = create_rect(b);

    return !(
        r2.left > r1.right ||
        r2.right < r1.left ||
        r2.top > r1.bottom ||
        r2.bottom < r1.top);
  };

  var get_closest_free = function(label, placed, dx, dy) {
    var copy = {x: label.x, y:label.y, width:label.width, height:label.height};
    var rel = {x: 0, y: 0, valid: true}
    var max_steps = 200;
    var steps = 0;

    for (var i=0; i<max_steps; i++) {
      steps++;
      var any_collision = false;
      for (var j=0; j<placed.length; j++) {
        var other = placed[j];
        if (collision(other, copy)) {
          any_collision = true;
          break;
        }
      }
      rel.steps = steps;
      if (!any_collision) {
        return rel;
      }

      rel.x += dx;
      rel.y += dy;
      copy.x += dx;
      copy.y += dy;
    }

    // Max steps reached.
    return {x: 0, y: 0, valid: false};
  };

  var step = function(placed, labels) {
      labels.sort(function(a, b) {return a.ox - b.ox;});

      directions = [
        [-1, -1],
        [-1,  0],
        [-1,  1],
        [ 0, -1],
        [ 1, -1],
        [ 1,  0],
        [ 1,  1],
        [ 0,  1],
      ]

      labels.map(function(label) {
        var min_dist = 9999999999999;
        var min = {x: 0, y: 0};
        directions.map(function(dir) {
          var rel = get_closest_free(label, placed, dir[0], dir[1]);
          var d = Math.sqrt(Math.pow(rel.x, 2) + Math.pow(rel.y, 2));

          if (rel.steps< min_dist) {
            min = rel;
            min_dist = rel.steps;
          }
        });

        label.x += min.x;
        label.y += min.y;
        placed.push(label);
      });
  }

  return {
    step: step,
    collision: collision
  }
})();

var makecluster = (function() {
  var clusters;
  var edges;
  var reverse_index;
  var clusterIndex;

  var _combineClusters = function(source, target) {
     adopting_cluster = reverse_index[source];
     purge_cluster = reverse_index[target];

     if (adopting_cluster === purge_cluster) {
       // Source and target are already in the same cluster. Do nothing
       return
     }

     // Merge the two clusters into a single cluster
     for (var index=0; index<clusters[purge_cluster].length; index++) {
       member = clusters[purge_cluster][index];
       clusters[adopting_cluster].push(member);
       reverse_index[member] = adopting_cluster;
     }

     delete clusters[purge_cluster];
   }

   var _adoptProbe = function(adopter, probe) {
     adopting_cluster = reverse_index[adopter];
     clusters[adopting_cluster].push(probe);
     reverse_index[probe] = adopting_cluster;
   }

   var _createCluster = function(members) {
     clusters[clusterIndex] = members;

     members.map(function(member) {
       reverse_index[member] = clusterIndex
     })

     clusterIndex++;
   }

  var add_pair = function(source, target) {
    if (!(source in edges)) {
      edges[source] = {};
    }

    if (!(target in edges)) {
      edges[target] = {};
    }

    edges[source][target] = true;
    edges[target][source] = true;

    if (source in reverse_index && target in reverse_index) {
      // Both source and target already added. Combine their clusters if necessary.
      _combineClusters(source, target)
    }
    else if (source in reverse_index && !(target in reverse_index)) {
      // Source exists in a cluster, target is new. Add target to source cluster
      _adoptProbe(source, target)
    }
    else if (!(source in reverse_index) && target in reverse_index) {
      // Target exists in a cluster, source is new. Add source to target cluster
      _adoptProbe(target, source)
    }
    else {
      // Neither source nor target exists in a cluster, create a new cluster
      _createCluster([source, target])
    }
  }

  this.from_links = function(_links) {
    clusters = {};
    edges = {};
    reverse_index = {};
    clusterIndex = 0;
    var cache = {};

    _links.map(function(link) {
      if (!link.source || !link.target) {
        throw 'link must contain source and target properties';
      }

      cache[link.source.id] = link.source;
      cache[link.target.id] = link.target;

      add_pair(link.source.id, link.target.id);
    });

    for (var cid in clusters) {
      clusters[cid].map(function(member_id, i) {
        clusters[cid][i] = cache[member_id];
      })
    };

    return clusters;
  }

  return this
})();

var simmelian = (function() {
  this.compute_tie_strength = function(all_links) {
    var tie_strengths = {};

    for (var member in all_links) {
      var strengths = []

      var a = Object.keys(all_links[member]);

      for (var contact in all_links[member]) {
        var b = Object.keys(all_links[contact]);

        var a_strength = 0;
        var b_strength = 0;

        a.map(function(x) {
          if (x in all_links[contact]) {
            a_strength++;
          }
        });

        b.map(function(z) {
          if (z in all_links[member]) {
            b_strength++;
          }
        });

        var strength = Math.max(1, a_strength, b_strength) / Math.max(a.length - 1, b.length - 1);

        strengths.push({member: contact, strength: strength});
      }

      strengths.sort(function(a, b) {
        return b.strength - a.strength;
      });

      tie_strengths[member] = {};

      strengths.map(function(c, i) {
        tie_strengths[member][c.member] = i;
      })
    }

    return tie_strengths;
  }

  this.structural_embeddedness = function(strengths, a, b) {
    var a_length = Object.keys(strengths[a]).length;

    var embeddedness = a_length;

    for (var c in strengths[a]) {
      if (c === b) continue;

      if (c in strengths[b]) {
        x = strengths[a][c];
        y = strengths[b][c];
        embeddedness -= Math.abs(x - y) / a_length;
      }
      else {
        embeddedness -= 1;
      }
    }

    return embeddedness / a_length;
  }

  this.filter = function(all_links, threshold) {
    var tie_strengths = this.compute_tie_strength(all_links);
    var filtered = {};
    var s;

    for (var a in all_links) {
      filtered[a] = {}
      for (var b in all_links[a]) {
        s = this.structural_embeddedness(tie_strengths, a, b);

        if (s < threshold) {
          filtered[a][b] = s;
        }
      }
    }

    return filtered;
  }

  return this;
})();

var merger = (function() {
  return {
    merge: function(graph, selected) {
      var merged_graph = {
        nodes: [],
        links: [],
        all_links: graph.all_links,
        member_map: graph.member_map,
        group_map: {}
      };
      var merge = {};

      var remove = [];
      var x = 0, y = 0;

      var group_cache = {};
      var merged_group_cache = {};
      var group;

      if (selected.length< 2) selected;
      var new_members = [];

      var merged_group = {
        id: '',
        members: new_members,
        x: 0,
        y: 0,
      };

      var local_groups = {}

      selected.map(function(node) {
        var group_id = graph.member_map[node.id].group;

        if (!(group_id in group_cache)) {
          group_cache[group_id] = true;
          local_groups[group_id] = true;

          if (merged_group.id.length > 0) {
              merged_group.id += "-";
          }

          merged_group.id += group_id;

          merge[group_id] = merged_group;

          var group = graph.nodes[graph.group_map[group_id]];

          // Group created as part of this merge.
          if (!group) {
            group = merged_graph.nodes[merged_graph.group_map[group_id]];
          }

          merged_group.x += group.x;
          merged_group.y += group.y;

          group.members.map(function(member) {
            new_members.push(member);
          });
        }
      });

      merged_group.x /= Object.keys(local_groups).length;
      merged_group.y /= Object.keys(local_groups).length;

      merged_graph.all_links[merged_group.id] = {};

      new_members.map(function(member) {
        merged_graph.member_map[member.id].group = merged_group.id;
        graph.member_map[member.id].group = merged_group.id
      });

      merged_group_cache[merged_group.id] = merged_group;

      merged_graph.group_map[merged_group.id] = merged_graph.nodes.length;
      merged_graph.nodes.push(merged_group);


      graph.nodes.map(function(group) {
        if (!(group.id in merge)) {
          merged_graph.group_map[group.id] = merged_graph.nodes.length;
          merged_graph.nodes.push(group);
        }
      });

      graph.links.map(function(link) {
        if (!link.source.id) link.source = {id: link.source}
        if (!link.target.id) link.target = {id: link.target}
        
        // Link not changed.
        if (link.source.id in merge && link.target.id in merge) { return; }

        if (link.source.id in merge && merged_group_cache[merge[link.source.id].id]) {
          link.source = merged_group_cache[merge[link.source.id].id];
        }

        if (link.target.id in merge && merged_group_cache[merge[link.target.id].id]) {
          link.target = merged_group_cache[merge[link.target.id].id];
        }

        if (link.source.id !== link.target.id) {
          merged_graph.all_links[link.source.id][link.target.id] = true;
          merged_graph.all_links[link.target.id][link.source.id] = true;
        }

        merged_graph.links.push({
          source: link.source.id,
          target: link.target.id
        });
      });

      return merged_graph;
    }
  }
})();

var remover = (function() {
  return {
    remove: function(graph, selected_groups) {
      var modified_graph = {
        nodes: [],
        links: [],
        all_links: graph.all_links,
        group_map: {},
        member_map: graph.member_map
      };
      var members_to_remove = {}

      selected_groups.map(function(group) {
        group.map(function(member) {
          members_to_remove[member.id] = true;
        });
      });

      graph.nodes.map(function(group) {
        var existing_members = group.members;
        group.members = [];

        existing_members.map(function(member) {
          if (member.id in members_to_remove) {
            delete modified_graph.all_links[member.id];
            delete modified_graph.member_map[member.id];
          }
          else {
            group.members.push(member);
          }
        });

        if (group.members.length > 0) {
          modified_graph.group_map[group.id] = modified_graph.nodes.length;
          modified_graph.nodes.push(group);
        }
      });

      graph.links.map(function(link) {
        if (link.source.id in modified_graph.group_map && link.target.id in modified_graph.group_map) {
          modified_graph.links.push(link)
        }
        else {
          // we don't know/case if the links are registered reflexively.
          try {
            delete modified_graph.all_links[link.source.id][link.target.id];
          } catch (e) {}
          try {
            delete modified_graph.all_links[link.target.id][link.source.id];
          } catch (e) {}
        }
      });

      return modified_graph;
    }
  }
})();

var splitter = (function() {
  return {
    split: function(graph, selected_groups) {
      var groups_to_split = {};

      if (selected_groups[0].constructor !== Array) {
        selected_groups = [selected_groups];
      }

      selected_groups.map(function(members) {
        members.map(function(member) {
          var group = graph.member_map[member.id].group;
          if (!(group in groups_to_split)) groups_to_split[group] = {};
          groups_to_split[group][member.id] = true;
        });
      });

      for (var group in groups_to_split) {
        if (Object.keys(groups_to_split[group]).length < 2) {
          delete groups_to_split[group];
        }
      }

      var split_graph = {
        nodes: [],
        links: [],
        all_links: graph.all_links,
        member_map: graph.member_map,
        group_map: {}
      };

      var splitted_groups = {};

      for (var group_id in groups_to_split) {
        splitted_groups[group_id] = true;
        var group_to_split = graph.nodes[graph.group_map[group_id]];

        if (group_to_split.members.length === 1) continue;

        group_to_split.members.map(function(member) {
          var group = {id: member.id, x: group_to_split.x, y: group_to_split.y, members: [member]};
          split_graph.member_map[member.id].group = member.id;
          split_graph.group_map[member.id] = split_graph.nodes.length;
          split_graph.nodes.push(group);
        });

        delete split_graph.all_links[group_id]
      }

      graph.nodes.map(function(group) {
        if (!(group.id in splitted_groups)) {
          split_graph.group_map[group.id] = split_graph.nodes.length;
          split_graph.nodes.push(group);
        }
      });

      split_graph.nodes.map(function(group) {
        group.members.map(function(member) {
          var group = split_graph.member_map[member.id].group;

          for (var other_id in graph.all_links[group]) {
            if (other_id in split_graph.group_map) {
              split_graph.links.push({source: group, target: other_id});
            }
            else {
              delete graph.all_links[member.id][other_id]
            }
          }
        });
      });

      return split_graph;
    }
  }
})();

var groups = (function() {
  // Groups of 1 or more nodes.
  var sizes = {};
  var color = d3.scaleOrdinal(d3.schemeCategory20c);
  var pie_limit = 4;

  this.set_pie_limit = function(_pie_limit) {
    pie_limit = _pie_limit;
  };

  this.clear_all = function() {
    color = d3.scaleOrdinal(d3.schemeCategory20c);

    cache = {};
    all = [];
  }

  var circle_radius = 5;
  var circle_margin = 2;

  var get_circle_position = function(circle_size, circle_index) {
    var ring_number = 1;
    var index = 0;

    while (index < circle_index) {
      var ring_circumference = (circle_size * ring_number) * 2 * Math.PI;
      var circles_in_ring = Math.floor(ring_circumference / circle_size);
      index += circles_in_ring;
      ring_number++;
    }

    ring_number--;

    var ring_circumference = circle_size * Math.max(1,ring_number) * 2 * Math.PI;
    var circles_in_ring = Math.floor(ring_circumference / circle_size);

    var radians = (((circle_index - index - 1) % circles_in_ring) * 360 / circles_in_ring) * (Math.PI / 180);
    var y = (ring_number * circle_size) * Math.cos(radians)
    var x = (ring_number * circle_size) * Math.sin(radians)

    return {x: x, y: y, rings: ring_number}
  }

  var draw_group_background = function(outer, group,  scale) {
    var id = group.id;
    var member_count = group.members.length;
    var background_radius = member_count + 5;

    if (member_count > pie_limit) {
      var rings = get_circle_position(circle_radius * 2 + circle_margin * 2, member_count - 1).rings;
      background_radius = (circle_radius * scale + circle_margin + (circle_radius * scale * 2 * rings + circle_margin * rings)) + 3;
    }

    outer.append("circle").attr("r", background_radius).attr("name", 'group-background');
    var circle = outer.append("circle")
      .attr("r", background_radius).attr("name", 'group-foreground')
      .attr('id', id)
      .attr("fill", color(id)).attr("fill-opacity", 0.2)
      .attr('stroke', color(id)).attr('stroke-width', 1)
      .on("click", function() {
        if (!d3.event.shiftKey) { selection.clear(); }
        //simulation.stop();

        group.members.map(function(node) {
          selection.add(node);
        })
      });

    return {
      circle: circle,
      radius: background_radius
    }
  }

  this.create_group = function(graph, g, group, label_container) {
    sizes[group.id] = {
      width: function() {
        return g.node().getBBox().width;
      },
      height: function() {
        return g.node().getBBox().height;
      }
    };

    var group_background = g.append('g').attr('class', 'outer');
    var group_labels = g.append('g').attr('class', 'labels');
    var group_members = g.append('g').attr('class', 'inner');

    var scale = Math.max(0.4, (1/Math.max(1, Math.log(group.members.length))));

    group.members.map(function(member, i) {
      var node;
      var position;

      if (group.members.length > 1 && group.members.length < pie_limit + 1) {
        node = nodes.create_pie(graph, group_members, member, i, group.members.length);
        position = {x: 0, y: 0};
      }
      else {
        node = nodes.create_node(graph, group_members, member, scale);
        position = get_circle_position(node.radius() * 2 + circle_margin, i);
      }

      graph.member_map[member.id].node = node;
      graph.member_map[member.id].circle = member.circle;
      graph.member_map[member.id].label = labels.create_label(label_container, member, node.attr('fill'));
      graph.member_map[member.id].cx = position.x;
      graph.member_map[member.id].cy = position.y;

      node.set_position(position.x, position.y);

      group.radius = node.radius();
    });

    if (group.members.length > 1) {
      g.attr('name', 'composite');
      var background = draw_group_background(group_background, group, scale);
      group.radius = background.radius;

      return background.circle;
    }
  }

  return this;
})();

var labels = (function() {
  // Used if bounding box is not available
  var default_box = {
    x: 0, y: 0,
    height: 20,
    width: 100
  }
  this.create_label = function(g, member, color) {
    var line = g.append('polyline');
    var label = g.append('g');

    var text_background_background = label.append('rect')
      .attr('class', 'text-background-background')
      .attr('stroke', color)
      .attr('rx', 2).attr('ry', 2)
      .attr('cx', 0).attr('cy', 0);

    var text_background = label.append('rect')
      .attr('class', 'text-background')
      .attr('fill', color)
      .attr('rx', 2).attr('ry', 2)
      .attr('cx', 0).attr('cy', 0);

    var text = label.append('text')
      .attr('cx', 2).attr('cy', 2)
      .attr('class', 'label').text(member.id)

    return {
      show: function() {
        label.attr('class', 'visible');
        line.attr('class', 'visible');
      },
      hide: function() {
        label.attr('class', null);
        line.attr('class', null);
      },
      width: function() {
        return text_background.node().getBBox().width;
      },
      height: function() {
        return text_background.node().getBBox().height;
      },
      move: function(cx, cy, px, py) {
        label.attr('transform', 'translate(' + px + ',' + py + ')');
        var d = cy > py ? -5 : 5;
        line.attr('points', marker.to_str([
          [cx, cy],
          [px, cy + d],
          [px, py]
        ], 1))
      },
      prepare: function() {
        var text_size = text.node().getBBox ? text.node().getBBox() : default_box;
        text_background.attr('width', text_size.width + 6);
        text_background.attr('height', text_size.height);
        text_background.attr('y', (text_size.height) * -0.5);
        text_background.attr('x', (text_size.width + 6) / -2);

        text_background_background.attr('width', text_size.width + 6);
        text_background_background.attr('height', text_size.height);
        text_background_background.attr('y', (text_size.height) * -0.5);
        text_background_background.attr('x', (text_size.width + 6) / -2);

        text.attr('y', 4);
        text.attr('x', text_size.width / -2);
      }
    };
  }

  return this;
})();

var member_lines = (function() {
  var container;

  return {
    init: function(_container) {
      container = _container;
    },
    add: function(start_x, start_y, end_x, end_y) {
      container.append("line")
        .attr("class", "selected")
        .attr("x1", start_x).attr("y1", start_y)
        .attr("x2", end_x).attr("y2", end_y);
    },
    clear: function() {
      container.selectAll('line').remove();
    }
  }
})();

var nodes = (function() {
  var circle_radius = 5;
  var color = d3.scaleOrdinal(d3.schemeCategory10);

  this.clear = function() {
    //color = d3.scaleOrdinal(d3.schemeCategory10);
  }

  var circle_click = function(graph, member) {
    if (!d3.event.shiftKey) {
      selection.clear();
      member_lines.clear();
    }

    var draw_member_lines = true;

    if (selection.size() > 0) {
      member_lines.clear();
      draw_member_lines = false;
    }

    var group = graph.nodes[graph.group_map[graph.member_map[member.id].group]];

    selection.add(member);

    if (!draw_member_lines) {
      selection.clear_contacts();
      return;
    }

    var start_x = group.x + member.circle.attr('cy')*1;
    var start_y = group.y + member.circle.attr('cx')*1;

    for (var cid in graph.all_links[member.id]) {
      var contact_member = graph.member_map[cid];
      var contact_group = graph.nodes[graph.group_map[contact_member.group]];

      // They are in the same group.
      if (contact_member.group === member.group) { continue }

      var end_x = contact_group.x + contact_member.cx;
      var end_y = contact_group.y + contact_member.cy;


      member_lines.add(start_x, start_y, end_x, end_y);
      selection.add(contact_member, 'contact');
    }
  };

  var generateWedgeString = function(startX, startY, startAngle, endAngle, radius){
      var x1 = (startX + radius * Math.cos(Math.PI * startAngle/180)).toFixed(4);
      var y1 = (startY + radius * Math.sin(Math.PI * startAngle/180)).toFixed(4);
      var x2 = (startX + radius * Math.cos(Math.PI * endAngle/180)).toFixed(4);
      var y2 = (startY + radius * Math.sin(Math.PI * endAngle/180)).toFixed(4);
      var pathString = "M"+ startX + " " + startY + " L" + x1 + " " + y1 + " A" + radius + " " + radius + " 0 0 1 " + x2 + " " + y2 + " z";
      return pathString;
  }

  this.create_pie = function(graph, g, member, index, total) {
    var node = g.append('g').attr('class', 'membernode').attr('id', member.id)
      .attr('fill', color(member.type))
      .attr('name', 'default').on("click", function() {
        circle_click(graph, member);
      });

    var start = 90;
    var degrees = 360 / total;
    var start_deg = start + degrees * index;
    var end_deg = start + degrees * (index + 1);

    var arc = node.append("path").attr("d", generateWedgeString(0, 0, start_deg, end_deg, 5))
      .attr("class", "member");

    member.circle = arc;

    node.radius = function() {
      return 5;
    }

    node.set_position = function(x, y) {
      //
    };

    return node;
  }

  this.create_node = function(graph, g, member, scale) {
    var node = g.append('g').attr('class', 'membernode').attr('id', member.id)
      .attr('fill', color(member.type))
      .attr('name', 'default').on("click", function() {
        circle_click(graph, member);
      });

    var background = node.append("circle").attr("r", circle_radius * scale)
      .attr("class", "member-background");

    var circle = node.append("circle").attr("r", circle_radius * scale)
      .attr("class", "member");

    node.radius = function() {
      return circle_radius * scale;
    }

    member.circle = circle;

    node.set_position = function(x, y) {
      circle.attr('cx', x);
      circle.attr('cy', y);
      background.attr('cx', x);
      background.attr('cy', y);
    };

    return node;
  };

  return this;
})();

var selection = (function() {
  var listeners = [];
  var all = [];
  var selected = {};
  var map = {}

  var timeout;

  return {
    listen: function(callback) {
      listeners.push(callback);
    },
    notify: function() {
      listeners.map(function(listener) {
        listener();
      });
    },
    size: function() {
      return all.length;
    },
    add: function(node, role) {
      if (!node.id) {
        console.log('invalid node ' + node);
        return;
      }
      if (!role) {
        role = 'selected';
      }
      if (!(node.id in map)) {
        all.push(node);
      }
      map[node.id] = node;
      if (role == 'selected') {
          selected[node.id] = node;
      }
      this.notify();
    },
    is_selected: function(node) {
      return node.id in map;
    },
    clear: function() {
      selected = {};
      all = [];
      map = {};
      this.notify();
    },
    clear_contacts: function() {
      all = [];

      for (var sel in selected) {
        all.push(selected[sel]);
      }

      this.notify();
    },
    selected: function() {
      return selected;
    },
    all: function() {
      return all;
    }
  }
})();

'use strict'

var ggraph = (function() {
  var started;
  var container;
  var all;
  var background_lines_container;
  var callbacks = [];
  var transform;
  var svg;
  var background;
  var draw;
  var simulation;
  var link;
  var node;
  var already_selected;
  var graph;
  var labels_container;
  var width;
  var height;
  var root;

  var select = function(hide_labels) {
    var all_nodes = selection.all();
    var selected_nodes = selection.selected();

    d3.select('svg').attr('name', all_nodes.length > 0 ? 'filtered' : '');
    d3.selectAll('.member').attr('name', 'default');
    d3.selectAll('.visible').attr('class', '');

    if (all_nodes.length > 0) simulation.stop();

    var labels = [];
    var circles = [];
    var node_cache = {};

    var from_x, from_y, to_x, to_y;

    all_nodes.map(function(member) {
      member.circle.attr('name', selected_nodes && member.id in selected_nodes ? 'selected' : 'contact');
      member = graph.member_map[member.id];
      if (!hide_labels && selection.size() < 100) {
        var group = graph.nodes[graph.group_map[member.group]];
        if (!(member.group in node_cache)) {
          node_cache[member.group] = {
            x: group.x, y: group.y,
            width: group.radius * 2,
            height: group.radius * 2,
          };
          circles.push(node_cache[member.group]);
        }

        member.label.show();
        member.label.prepare();

        labels.push({
          x: group.x + member.cx,
          y: group.y + member.cy,
          ox: group.x + member.cx,
          oy: group.y + member.cy,
          cx: member.cx,
          cy: member.cy,
          width: member.label.width(),
          height: member.label.height(),
          label: member.label,
          group: group
        });
      }
    });

    ladjust.step(circles, labels);

    labels.map(function(member) {
      if (!member.label) return;

      from_x = member.group.x + member.cx;
      from_y = member.group.y + member.cy;
      to_x = member.group.x + member.cx + member.x - member.ox;
      to_y = member.group.y + member.cy + member.y - member.oy;

      member.label.move(from_x, from_y, to_x, to_y);
    });
  }

  var clear_selected = function() {
    d3.select(root).selectAll('circle.member').attr('name', 'default');
    member_lines.clear();
    selection.clear();
    simulation.restart();
  };

  function ticked() {
    // bounding box
    //node.attr("x", function(d) { return d.x = Math.max(groups.get_group(d.id).group.radius, Math.min(width - groups.get_group(d.id).group.radius, d.x)) });
    //node.attr("y", function(d) { return d.y = Math.max(groups.get_group(d.id).group.radius, Math.min(height - groups.get_group(d.id).group.radius, d.y))  });
    node.attr("x", function(d) { return d.x });
    node.attr("y", function(d) { return d.y });
    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y +")"; });

    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
  }

  var init = function(_root) {
    root = _root;
    if (root.constructor === String) {
      root = document.getElementById(root)
    }
    root.innerHTML = '';
    root.addEventListener('contextmenu', function(e) {e.preventDefault()});

    var element = root.getBoundingClientRect();
    width = element.width;
    height = element.height;

    transform = {current: {k: 1, x: 0, y: 0}};

    svg = d3.select(root).append('svg').call(d3.zoom().on("zoom", function () {
      all.attr("transform", d3.event.transform)
      transform.current = d3.event.transform;
    }));

    background = svg.append('g').append('rect').attr('width', element.width).attr('height', element.height)
      .attr('x', 0).attr('y', 0).attr('id', 'background').on('click', function() {
        clear_selected();
    });

    all = svg.append('g').attr('id', 'all');
    container = all.append('g')
    draw = all.append('g')
    background_lines_container = all.append('g')
    labels_container = all.append('g').attr('class', 'labels');

    simulation = d3.forceSimulation()
      .force("center", d3.forceCenter(element.width / 2, element.height / 2))
      .force('charge', d3.forceManyBody().strength(charge))
      .force("link", d3.forceLink().id(function(d) { return d.id; }).strength(link_strength))
        //.distance(100);

    callbacks.push(function(all, selected) {
      select(all, selected);
    });

    selection.listen(function() {
      var all = selection.all();
      var selected = selection.selected();
      var current = all.map(function(node) {return node.id});
      if (current.join(',') !== already_selected) {
        callbacks.map(function(callback) {
          callback();
        });
      }

      already_selected = current.join(',');
    });

    member_lines.init(background_lines_container);

    marker.init(draw, svg, transform, element.left * -1, element.top * -1);

    marker.marked(function(clear) {
      simulation.stop();
      if (clear) {
        selection.clear();
      }

      for (var member_id in graph.member_map) {

        var member = graph.member_map[member_id];
        if (selection.is_selected(member)) {
          continue
        }

        var group = graph.nodes[graph.group_map[member.group]];

        var point = [
          group.x + member.circle.attr('cx') *  1,
          group.y + member.circle.attr('cy') *  1
        ];

        if (marker.contains(point)) {
          selection.add(member);
        }
      }
    });
  };

  var charge = function(d) {
    return -50;
  };

  var link_strength = function(d) {
    if (d.filtered) return 0.01  / (d.source.members.length * d.target.members.length);
    return 1 / (d.source.members.length + d.target.members.length);
  };

  var drag = d3.drag()
    .on("start", function(d) {
      started = true;
      if (!d3.event.active) {
        simulation.alphaTarget(0.3).restart();
      }
      d.fx = d.x;
      d.fy = d.y;
    })
    .on("drag", function(d) {
      member_lines.clear();
      started = true;
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    })
    .on("end", function(d) {
      started = false;
      if (!d3.event.active) {
        simulation.alphaTarget(0);
      }
      d.fx = null;
      d.fy = null;
    });

  var _draw = function(_graph) {
    groups.clear();

    container.selectAll('*').remove();

    graph = _graph;

    graph.links.sort(function(a, b) {
      if (a.filtered && !b.filtered) {
        return -1;
      }

      if (!a.filtered && b.filtered) {
        return 1;
      }

      return 0;
    });

    link = container.append("g")
      .attr("class", "links").selectAll("line").data(graph.links).enter().append("line").attr('class', 'rel').attr("stroke-width", function(d, e) {
        d3.select(this).attr('name', d.filtered ? 'filtered' : '')
        if (!d.value) d.value = 1;
        return Math.sqrt(d.value);
      });

    var start = new Date().getTime() / 1000;
    node = container.append("g")
      .attr("class", "nodes").selectAll("g").data(graph.nodes).enter().append('g').attr('class', 'node').call(drag).each(function(d) {
        groups.create_group(graph, d3.select(this), d, labels_container);
      });
    var end = new Date().getTime() / 1000;

    simulation.nodes(graph.nodes).force("link").links(graph.links)
    simulation.on("tick", ticked);
    simulation.alpha(1).restart();
  };

  var split = function(selected) {
    var splitted_graph = splitter.split(graph, selected);
    _draw(splitted_graph);
    selection.clear();
    simulation.restart();
  }

  var _merge = function(selected, collapse) {
    if (!selected || !selected[0]) return;
    var s = [];
    if (selected[0].constructor === Array && collapse) {
      selected.map(function(a) {
        Array.prototype.push.apply(s, a);
      })
      selected = s;
    }

    if (selected[0].constructor === Array) {
        _merge_groups(selected);
    }
    else {
      _merge_groups([selected]);
    }

    selection.clear();
    d3.select('svg').attr('name', '');
    d3.selectAll('g[name=selected]').attr('name', 'default');
    d3.selectAll('.visible').attr('class', '');
  }

  var _remove = function(selected) {
    if (selected[0].constructor !== Array) {
      selected = [selected];
    }

    var modified_graph = remover.remove(graph, selected);

    if (modified_graph.nodes.length < graph.nodes.length) {
      member_lines.clear();
      graph = modified_graph;
      ggraph.draw(graph);
      simulation.restart();
    }

    selection.clear();
  }

  var cluster = function(selected) {
    var clusters = [];
    var computed = makecluster.from_links(selected);
    for (var c in computed) {
      clusters.push(computed[c]);
    }

    return clusters;
  }

  var _merge_groups = function(selected_groups) {
    var merged_graph = graph;

    selected_groups.map(function(selected) {
      merged_graph = merger.merge(merged_graph, selected);
    });

    if (merged_graph.nodes.length < graph.nodes.length) {
      member_lines.clear();
      graph = merged_graph;
      ggraph.draw(merged_graph);
      simulation.alpha(0.2).restart();
    }

    selection.clear();
  }

  var filter_links = function(map) {
    container.attr('name', 'backbone')
    graph.links.map(function(link) {
      if (link.source.id in map && link.target.id in map[link.source.id]
      && link.target.id in map && link.source.id in map[link.target.id]) {
        link.filtered = true;
      }
      /*else if (link.value === 1) {
        link.filtered = true;
      }*/
      else {
        link.filtered = false;
      }
    });

    ggraph.draw(graph);
    simulation.alpha(1).restart();
  }

  var convert = function(graph) {
    var converted = JSON.parse(JSON.stringify(graph))

    converted.group_map = {};
    converted.member_map = {};
    converted.all_links = {};

    converted.nodes.map(function(group, i) {
      if (!group.id) converted.nodes[i] = {id:group}
      group = converted.nodes[i];
      var member_type = 'entity';
      if (group.type) {
        member_type = group.type;
        delete group.type;
      }
      group.members = [{id: group.id, type: member_type}];
      converted.group_map[group.id] = i;
      converted.member_map[group.id] = {
        type: member_type,
        id: group.id,
        group: group.id
      };
    });

    converted.links.map(function(link) {
      if (!link.source.id) link.source = converted.nodes[converted.group_map[link.source]];
      if (!link.target.id) link.target = converted.nodes[converted.group_map[link.target]];
      if (!(link.source.id in converted.all_links)) { converted.all_links[link.source.id] = {}; }
      if (!(link.target.id in converted.all_links)) { converted.all_links[link.target.id] = {}; }
      if (converted.all_links[link.source.id][link.target.id] === undefined) converted.all_links[link.source.id][link.target.id] = 0;
      if (converted.all_links[link.target.id][link.source.id] === undefined) converted.all_links[link.target.id][link.source.id] = 0;
      converted.all_links[link.source.id][link.target.id]++;
      converted.all_links[link.target.id][link.source.id]++;
    });

    converted.links.map(function(link) {
      link.value = converted.all_links[link.target.id][link.source.id];
    });

    return converted;
  }

  var register = function(callback) {
    callbacks.push(callback);
  }

  var set_graph = function(_graph) {
    graph = _graph;
  }

  return {
    init: init,
    draw: _draw,
    on_select: register,
    select: select,
    merge: _merge,
    remove: _remove,
    merge_groups: _merge_groups,
    split: split,
    convert: convert,
    ticked: ticked,
    clear_selected: clear_selected,
    cluster: cluster,
    filter_links: filter_links
  }
})();
